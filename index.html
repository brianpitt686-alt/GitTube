<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GitTube - Offline Edition</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: "class",
      theme: { extend: { fontFamily: { sans: ["Inter", "sans-serif"] } } },
    };
  </script>

  <!-- Smooth page + modal animations (no external libs) -->
  <style>
    /* small, smooth transitions without heavy frameworks */
    .fade-enter { opacity: 0; transform: translateY(8px); }
    .fade-enter-active { opacity: 1; transform: translateY(0); transition: opacity 220ms ease, transform 220ms ease; }

    .modal-enter { opacity: 0; transform: translateY(16px) scale(0.98); }
    .modal-enter-active { opacity: 1; transform: translateY(0) scale(1); transition: opacity 220ms ease, transform 220ms ease; }

    .sheet-enter { transform: translateX(-12px); opacity: 0; }
    .sheet-enter-active { transform: translateX(0); opacity: 1; transition: opacity 220ms ease, transform 220ms ease; }

    @media (prefers-reduced-motion: reduce) {
      .fade-enter-active, .modal-enter-active, .sheet-enter-active { transition: none !important; }
      .fade-enter, .modal-enter, .sheet-enter { transform: none !important; }
    }
  </style>

  <!-- React -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>

<body class="bg-neutral-50 dark:bg-neutral-900 text-neutral-900 dark:text-neutral-100 transition-colors">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo, useLayoutEffect } = React;

    // ---------- Inline SVG Icons ----------
    const Icon = ({ path, className = "w-5 h-5", fill = "none" }) => (
      <svg
        className={className}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill={fill}
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        dangerouslySetInnerHTML={{ __html: path }}
      />
    );
    const Search = ({ className }) => <Icon className={className} path='<circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/>' />;
    const Menu = ({ className }) => <Icon className={className} path='<line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="18" x2="20" y2="18"/>' />;
    const Home = ({ className }) => <Icon className={className} path='<path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/>' />;
    const Compass = ({ className }) => <Icon className={className} path='<circle cx="12" cy="12" r="10"/><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"/>' />;
    const ThumbsUp = ({ className }) => <Icon className={className} path='<path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"/>' />;
    const History = ({ className }) => <Icon className={className} path='<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M12 7v5l4 2"/>' />;
    const Play = ({ className }) => <Icon className={className} path='<polygon points="5 3 19 12 5 21 5 3"/>' />;
    const Share2 = ({ className }) => <Icon className={className} path='<circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>' />;
    const Check = ({ className }) => <Icon className={className} path='<polyline points="20 6 9 17 4 12"/>' />;
    const Moon = ({ className }) => <Icon className={className} path='<path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/>' />;
    const Sun = ({ className }) => <Icon className={className} path='<circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/>' />;
    const Plus = ({ className }) => <Icon className={className} path='<line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>' />;
    const X = ({ className }) => <Icon className={className} path='<line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>' />;
    const Trash2 = ({ className }) => <Icon className={className} path='<polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/>' />;

    // ---------- Utility ----------
    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

    const formatViews = (views) => {
      const v = Number(views || 0);
      if (v >= 1000000) return (v / 1000000).toFixed(1) + "M";
      if (v >= 1000) return (v / 1000).toFixed(1) + "K";
      return v.toString();
    };

    const formatTimeAgo = (dateString) => {
      if (!dateString) return "Just now";
      const date = new Date(dateString);
      if (Number.isNaN(date.getTime())) return "Just now";
      const now = new Date();
      const seconds = Math.floor((now.getTime() - date.getTime()) / 1000);

      let interval = seconds / 31536000;
      if (interval > 1) return Math.floor(interval) + " years ago";
      interval = seconds / 2592000;
      if (interval > 1) return Math.floor(interval) + " months ago";
      interval = seconds / 86400;
      if (interval > 1) return Math.floor(interval) + " days ago";
      interval = seconds / 3600;
      if (interval > 1) return Math.floor(interval) + " hours ago";
      interval = seconds / 60;
      if (interval > 1) return Math.floor(interval) + " mins ago";
      return "Just now";
    };

    const formatDuration = (seconds) => {
      const s0 = Number(seconds || 0);
      if (!s0) return "Live / VOD";
      const h = Math.floor(s0 / 3600);
      const m = Math.floor((s0 % 3600) / 60);
      const s = Math.floor(s0 % 60);
      if (h > 0) return `${h}:${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
      return `${m}:${s.toString().padStart(2, "0")}`;
    };

    // More robust YouTube ID parsing (watch, shorts, youtu.be, embed, etc.)
    const getYouTubeId = (url) => {
      if (!url) return null;
      try {
        const u = new URL(url);
        const host = u.hostname.replace(/^www\./, "");

        // youtu.be/<id>
        if (host === "youtu.be") {
          const id = u.pathname.split("/").filter(Boolean)[0];
          return id && id.length === 11 ? id : null;
        }

        // youtube.com/*
        if (host === "youtube.com" || host === "m.youtube.com" || host === "music.youtube.com" || host === "gaming.youtube.com") {
          // watch?v=<id>
          const v = u.searchParams.get("v");
          if (v && v.length === 11) return v;

          // shorts/<id>
          const parts = u.pathname.split("/").filter(Boolean);
          const shortsIdx = parts.indexOf("shorts");
          if (shortsIdx !== -1 && parts[shortsIdx + 1] && parts[shortsIdx + 1].length === 11) return parts[shortsIdx + 1];

          // embed/<id>
          const embedIdx = parts.indexOf("embed");
          if (embedIdx !== -1 && parts[embedIdx + 1] && parts[embedIdx + 1].length === 11) return parts[embedIdx + 1];
        }

        // fallback regex
        const regExp = /^.*(youtu\.be\/|v\/|u\/\w\/|embed\/|shorts\/|watch\?v=|&v=)([^#&?]*).*/;
        const match = url.match(regExp);
        return match && match[2] && match[2].length === 11 ? match[2] : null;
      } catch {
        // not a URL => regex fallback
        const regExp = /^.*(youtu\.be\/|v\/|u\/\w\/|embed\/|shorts\/|watch\?v=|&v=)([^#&?]*).*/;
        const match = (url + "").match(regExp);
        return match && match[2] && match[2].length === 11 ? match[2] : null;
      }
    };

    const getDriveId = (url) => {
      if (!url) return null;
      const match = url.match(/(?:drive\.google\.com\/(?:file\/d\/|open\?id=))([a-zA-Z0-9_-]+)/);
      return match ? match[1] : null;
    };

    const generateId = () => "vid_" + Date.now() + "_" + Math.random().toString(36).slice(2);

    // Thumbnail helper: maxres often 404 -> fall back to hqdefault
    const ytThumb = (ytId) => `https://img.youtube.com/vi/${ytId}/maxresdefault.jpg`;
    const ytThumbFallback = (ytId) => `https://img.youtube.com/vi/${ytId}/hqdefault.jpg`;

    // ---------- Mock Data ----------
    const initialVideos = [
      {
        id: "v1",
        title: "Big Buck Bunny (Open Source Movie)",
        description: "A large and lovable rabbit deals with three bullying rodents.",
        channelName: "Blender Foundation",
        publishedAt: "2008-04-10T00:00:00Z",
        views: 15432000,
        durationSeconds: 596,
        tags: ["animation", "blender", "open source"],
        thumbnailUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/c/c5/Big_buck_bunny_poster_big.jpg/640px-Big_buck_bunny_poster_big.jpg",
        videoUrl: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4",
        likes: [],
        uploaderId: "system",
        createdAt: 1,
      },
      {
        id: "v2",
        title: "Elephants Dream",
        description: "The first computer-generated animated short film produced entirely with free and open-source software.",
        channelName: "Blender Foundation",
        publishedAt: "2006-03-24T00:00:00Z",
        views: 4200000,
        durationSeconds: 653,
        tags: ["animation", "blender", "classic"],
        thumbnailUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/Elephants_Dream_s5_both.jpg/640px-Elephants_Dream_s5_both.jpg",
        videoUrl: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4",
        likes: [],
        uploaderId: "system",
        createdAt: 2,
      },
      {
        id: "yt1",
        title: "NASA's SpaceX Crew-8 Return to Earth",
        description: "Watch official NASA coverage as the SpaceX Crew-8 returns.",
        channelName: "NASA",
        publishedAt: "2024-03-15T12:00:00Z",
        views: 890000,
        durationSeconds: 3600,
        tags: ["space", "nasa", "science", "live"],
        thumbnailUrl: "https://img.youtube.com/vi/21X5lGlDOfg/hqdefault.jpg",
        videoUrl: "https://www.youtube.com/watch?v=21X5lGlDOfg",
        likes: [],
        uploaderId: "system",
        createdAt: 3,
      },
    ];

    // ---------- Anim helpers ----------
    function useEnterAnimation(depKey, baseClass, activeClass) {
      const [cls, setCls] = useState(baseClass);
      useLayoutEffect(() => {
        // reset then activate next frame
        setCls(baseClass);
        const id = requestAnimationFrame(() => setCls(baseClass + " " + activeClass));
        return () => cancelAnimationFrame(id);
      }, [depKey]);
      return cls;
    }

    // ---------- Subcomponents ----------
    function SidebarItem({ icon, label, active = false, onClick }) {
      return (
        <button
          onClick={onClick}
          className={`w-full flex items-center gap-4 px-3 py-2.5 rounded-lg transition-colors active:scale-[0.98] ${
            active ? "bg-neutral-200 dark:bg-neutral-800 font-medium" : "hover:bg-neutral-100 dark:hover:bg-neutral-800/50"
          }`}
        >
          <div className={`${active ? "text-black dark:text-white" : "text-neutral-700 dark:text-neutral-300"}`}>
            {React.cloneElement(icon, { className: "w-5 h-5" })}
          </div>
          <span>{label}</span>
        </button>
      );
    }

    function FilterChip({ label, active, onClick }) {
      return (
        <button
          onClick={onClick}
          className={`px-4 py-1.5 rounded-lg text-sm font-medium whitespace-nowrap transition-colors active:scale-[0.98] ${
            active
              ? "bg-black text-white dark:bg-white dark:text-black"
              : "bg-neutral-200 dark:bg-neutral-800 text-neutral-800 dark:text-neutral-200 hover:bg-neutral-300 dark:hover:bg-neutral-700"
          }`}
        >
          {label}
        </button>
      );
    }

    function SmartImage({ src, alt, className, fallbackSrc }) {
      const [imgSrc, setImgSrc] = useState(src);
      useEffect(() => setImgSrc(src), [src]);

      return (
        <img
          src={imgSrc}
          alt={alt}
          className={className}
          loading="lazy"
          onError={() => {
            if (fallbackSrc && imgSrc !== fallbackSrc) setImgSrc(fallbackSrc);
          }}
        />
      );
    }

    function VideoCard({ video, onClick, progress }) {
      const duration = Number(video.durationSeconds || 0);
      const progressSeconds = Number(progress || 0);
      const progressPercent = duration > 0 ? clamp((progressSeconds / duration) * 100, 0, 100) : 0;
      const likeCount = video.likes?.length || 0;

      const ytId = useMemo(() => getYouTubeId(video.videoUrl), [video.videoUrl]);
      const fallbackThumb = ytId ? ytThumbFallback(ytId) : null;

      return (
        <div className="flex flex-col gap-3 cursor-pointer group" onClick={onClick}>
          <div className="relative aspect-video rounded-xl overflow-hidden bg-neutral-200 dark:bg-neutral-800">
            <SmartImage
              src={video.thumbnailUrl}
              fallbackSrc={fallbackThumb}
              alt={video.title}
              className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
            />
            <div className="absolute bottom-1.5 right-1.5 bg-black/80 text-white text-xs font-medium px-1.5 py-0.5 rounded">
              {formatDuration(video.durationSeconds)}
            </div>
            {progressPercent > 0 && (
              <div className="absolute bottom-0 left-0 w-full h-1 bg-neutral-600/50">
                <div className="h-full bg-red-600" style={{ width: `${progressPercent}%` }} />
              </div>
            )}
          </div>

          <div className="flex gap-3 px-1">
            <div className="w-9 h-9 rounded-full bg-gradient-to-br from-blue-500 to-purple-600 flex-shrink-0" />
            <div className="flex flex-col">
              <h3 className="text-sm font-semibold line-clamp-2 leading-tight group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">
                {video.title}
              </h3>
              <span className="text-sm text-neutral-600 dark:text-neutral-400 mt-1">{video.channelName}</span>
              <span className="text-sm text-neutral-600 dark:text-neutral-400">
                {formatViews(video.views)} views â€¢ {likeCount} likes â€¢ {formatTimeAgo(video.publishedAt)}
              </span>
            </div>
          </div>
        </div>
      );
    }

    function HorizontalVideoCard({ video, onClick }) {
      const likeCount = video.likes?.length || 0;
      const ytId = useMemo(() => getYouTubeId(video.videoUrl), [video.videoUrl]);
      const fallbackThumb = ytId ? ytThumbFallback(ytId) : null;

      return (
        <div className="flex flex-col sm:flex-row gap-4 cursor-pointer group" onClick={onClick}>
          <div className="relative w-full sm:w-64 lg:w-80 aspect-video rounded-xl overflow-hidden flex-shrink-0 bg-neutral-200 dark:bg-neutral-800">
            <SmartImage
              src={video.thumbnailUrl}
              fallbackSrc={fallbackThumb}
              alt={video.title}
              className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
            />
            <div className="absolute bottom-1.5 right-1.5 bg-black/80 text-white text-xs font-medium px-1.5 py-0.5 rounded">
              {formatDuration(video.durationSeconds)}
            </div>
          </div>
          <div className="flex flex-col py-1">
            <h3 className="text-lg font-medium leading-tight mb-1 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">
              {video.title}
            </h3>
            <span className="text-xs text-neutral-600 dark:text-neutral-400 mb-2">
              {formatViews(video.views)} views â€¢ {likeCount} likes â€¢ {formatTimeAgo(video.publishedAt)}
            </span>
            <div className="flex items-center gap-2 mb-2">
              <div className="w-6 h-6 rounded-full bg-gradient-to-br from-blue-500 to-purple-600" />
              <span className="text-xs text-neutral-600 dark:text-neutral-400">{video.channelName}</span>
            </div>
            <p className="text-xs text-neutral-500 dark:text-neutral-500 line-clamp-2">{video.description}</p>
          </div>
        </div>
      );
    }

    function WatchView({
      video,
      videos,
      navigateTo,
      user,
      channels,
      initialProgress,
      onProgress,
      onDeleteVideo,
      onUpdateVideo,
      onUpdateChannel,
    }) {
      const videoRef = useRef(null);
      const [copied, setCopied] = useState(false);
      const [showDescription, setShowDescription] = useState(false);

      const youtubeId = useMemo(() => getYouTubeId(video.videoUrl), [video.videoUrl]);
      const driveId = useMemo(() => getDriveId(video.videoUrl), [video.videoUrl]);
      const isEmbed = !!youtubeId || !!driveId;

      const isLiked = user ? (video.likes || []).includes(user.uid) : false;
      const likeCount = (video.likes || []).length;
      const isOwner = user && video.uploaderId === user.uid;

      const channelId = (video.channelName || "Unknown").replace(/\s+/g, "_");
      const channelData = channels[channelId] || { subscribers: [] };
      const isSubscribed = user ? (channelData.subscribers || []).includes(user.uid) : false;
      const subCount = (channelData.subscribers || []).length;

      const handleToggleLike = () => {
        if (!user) return;
        const currentLikes = video.likes || [];
        const newLikes = isLiked ? currentLikes.filter((id) => id !== user.uid) : [...currentLikes, user.uid];
        onUpdateVideo(video.id, { likes: newLikes });
      };

      const handleToggleSubscribe = () => {
        if (!user) return;
        const currentSubs = channelData.subscribers || [];
        const newSubs = isSubscribed ? currentSubs.filter((id) => id !== user.uid) : [...currentSubs, user.uid];
        onUpdateChannel(channelId, { subscribers: newSubs });
      };

      const handleDelete = () => {
        const confirmDelete = window.confirm("Are you sure you want to delete this video? This cannot be undone.");
        if (confirmDelete) onDeleteVideo(video.id);
      };

      // Keyboard shortcuts for HTML5 video only
      useEffect(() => {
        if (isEmbed) return;

        const handleKeyDown = (e) => {
          const tag = document.activeElement?.tagName;
          if (tag === "INPUT" || tag === "TEXTAREA") return;

          const v = videoRef.current;
          if (!v) return;

          switch (e.key.toLowerCase()) {
            case " ":
            case "k":
              e.preventDefault();
              v.paused ? v.play() : v.pause();
              break;
            case "arrowleft":
              e.preventDefault();
              v.currentTime = Math.max(0, v.currentTime - 5);
              break;
            case "arrowright":
              e.preventDefault();
              v.currentTime = Math.min(v.duration || v.currentTime + 5, v.currentTime + 5);
              break;
            case "m":
              e.preventDefault();
              v.muted = !v.muted;
              break;
            case "f":
              e.preventDefault();
              if (!document.fullscreenElement) v.requestFullscreen?.().catch(() => {});
              else document.exitFullscreen?.();
              break;
          }
        };

        window.addEventListener("keydown", handleKeyDown);
        return () => window.removeEventListener("keydown", handleKeyDown);
      }, [isEmbed, video.id]);

      // Time tracking for non-embeds
      useEffect(() => {
        const v = videoRef.current;
        if (!v || isEmbed) return;

        const dur = Number(video.durationSeconds || 0);
        if (initialProgress > 0 && (dur === 0 || initialProgress < dur - 5)) {
          v.currentTime = initialProgress;
        }

        const interval = setInterval(() => {
          if (!v.paused) onProgress(v.currentTime);
        }, 5000);

        return () => clearInterval(interval);
      }, [video.id, isEmbed]); // eslint-disable-line

      const handleShare = () => {
        const url = `${window.location.origin}${window.location.pathname}?v=${video.id}`;
        navigator.clipboard
          .writeText(url)
          .then(() => {
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
          })
          .catch(() => {
            const textArea = document.createElement("textarea");
            textArea.value = url;
            document.body.appendChild(textArea);
            textArea.select();
            try {
              document.execCommand("copy");
              setCopied(true);
              setTimeout(() => setCopied(false), 2000);
            } catch {
              prompt("Copy this link:", url);
            }
            document.body.removeChild(textArea);
          });
      };

      const relatedVideos = useMemo(() => {
        const baseTags = video.tags || [];
        const scoreOf = (v) => {
          const tags = v.tags || [];
          let score = 0;
          for (const t of tags) if (baseTags.includes(t)) score++;
          return score;
        };

        return videos
          .filter((v) => v.id !== video.id)
          .map((v) => ({ video: v, score: scoreOf(v) }))
          .sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            const ta = new Date(a.video.publishedAt || 0).getTime();
            const tb = new Date(b.video.publishedAt || 0).getTime();
            return tb - ta;
          })
          .map((x) => x.video)
          .slice(0, 10);
      }, [video, videos]);

      // YouTube embed URL (more reliable + consistent)
      const ytEmbedUrl = useMemo(() => {
        if (!youtubeId) return null;
        const origin = encodeURIComponent(window.location.origin);
        // modest branding, no related vids, and allow fullscreen
        return `https://www.youtube-nocookie.com/embed/${youtubeId}?rel=0&modestbranding=1&playsinline=1&origin=${origin}`;
      }, [youtubeId]);

      const ytIdForThumbFallback = youtubeId;
      const fallbackThumb = ytIdForThumbFallback ? ytThumbFallback(ytIdForThumbFallback) : null;

      return (
        <div className="max-w-[1600px] mx-auto grid grid-cols-1 lg:grid-cols-3 xl:grid-cols-4 gap-6">
          <div className="lg:col-span-2 xl:col-span-3">
            <div className="w-full aspect-video bg-black rounded-xl overflow-hidden shadow-lg relative">
              {youtubeId ? (
                <iframe
                  src={ytEmbedUrl}
                  title={video.title}
                  className="w-full h-full border-0"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                  referrerPolicy="strict-origin-when-cross-origin"
                  allowFullScreen
                />
              ) : driveId ? (
                <iframe
                  src={`https://drive.google.com/file/d/${driveId}/preview`}
                  title={video.title}
                  className="w-full h-full border-0"
                  allow="autoplay"
                  referrerPolicy="strict-origin-when-cross-origin"
                  allowFullScreen
                />
              ) : (
                <video
                  ref={videoRef}
                  src={video.videoUrl}
                  poster={video.thumbnailUrl}
                  controls
                  autoPlay
                  controlsList="nodownload"
                  className="w-full h-full object-contain"
                >
                  Your browser does not support HTML5 video.
                </video>
              )}
            </div>

            <div className="mt-4">
              <h1 className="text-xl sm:text-2xl font-bold">{video.title}</h1>

              <div className="flex flex-col sm:flex-row sm:items-center justify-between mt-3 gap-4">
                <div className="flex items-center gap-3">
                  <div className="w-10 h-10 rounded-full bg-gradient-to-br from-blue-500 to-purple-600" />
                  <div>
                    <h3 className="font-bold leading-tight">{video.channelName}</h3>
                    <span className="text-xs text-neutral-600 dark:text-neutral-400">{subCount} subscribers</span>
                  </div>
                  <button
                    onClick={handleToggleSubscribe}
                    className={`ml-2 px-4 py-2 rounded-full font-medium transition-colors active:scale-[0.98] ${
                      isSubscribed
                        ? "bg-neutral-200 dark:bg-neutral-700 text-black dark:text-white"
                        : "bg-black text-white dark:bg-white dark:text-black hover:opacity-90"
                    }`}
                  >
                    {isSubscribed ? "Subscribed" : "Subscribe"}
                  </button>
                </div>

                <div className="flex items-center gap-2 overflow-x-auto pb-2 sm:pb-0">
                  {isOwner && (
                    <button
                      onClick={handleDelete}
                      className="flex items-center gap-2 px-4 py-2 bg-red-100 dark:bg-red-900/30 text-red-600 dark:text-red-400 hover:bg-red-200 dark:hover:bg-red-900/50 rounded-full font-medium transition-colors active:scale-[0.98]"
                    >
                      <Trash2 className="w-5 h-5" />
                      <span className="hidden sm:inline">Delete</span>
                    </button>
                  )}

                  <button
                    onClick={handleToggleLike}
                    className={`flex items-center gap-2 px-4 py-2 rounded-full font-medium transition-colors active:scale-[0.98] ${
                      isLiked
                        ? "bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400"
                        : "bg-neutral-100 dark:bg-neutral-800 hover:bg-neutral-200 dark:hover:bg-neutral-700"
                    }`}
                  >
                    <ThumbsUp className={`w-5 h-5 ${isLiked ? "text-blue-600 dark:text-blue-400 fill-current" : ""}`} />
                    <span>{likeCount}</span>
                  </button>

                  <button
                    onClick={handleShare}
                    className="flex items-center gap-2 px-4 py-2 bg-neutral-100 dark:bg-neutral-800 hover:bg-neutral-200 dark:hover:bg-neutral-700 rounded-full font-medium transition-colors active:scale-[0.98]"
                  >
                    {copied ? <Check className="w-5 h-5 text-green-500" /> : <Share2 className="w-5 h-5" />}
                    <span>{copied ? "Copied" : "Share"}</span>
                  </button>
                </div>
              </div>

              <div
                className="mt-4 bg-neutral-100 dark:bg-neutral-800/50 rounded-xl p-3 sm:p-4 text-sm hover:bg-neutral-200 dark:hover:bg-neutral-800 transition-colors cursor-pointer"
                onClick={() => setShowDescription((s) => !s)}
                role="button"
                tabIndex={0}
              >
                <div className="font-medium mb-1">{formatViews(video.views)} views â€¢ {formatTimeAgo(video.publishedAt)}</div>

                <p className={`whitespace-pre-wrap ${showDescription ? "" : "line-clamp-2"}`}>{video.description}</p>

                {!showDescription && (
                  <button
                    className="font-bold mt-2"
                    onClick={(e) => {
                      e.stopPropagation(); // prevent double toggle weirdness
                      setShowDescription(true);
                    }}
                  >
                    Show more
                  </button>
                )}

                <div className="mt-3 flex gap-2 flex-wrap">
                  {(video.tags || []).map((tag) => (
                    <span key={tag} className="text-blue-600 dark:text-blue-400">#{tag.replace(/\s+/g, "")}</span>
                  ))}
                </div>
              </div>
            </div>
          </div>

          <div className="lg:col-span-1 flex flex-col gap-3">
            {relatedVideos.map((v) => {
              const ytId = getYouTubeId(v.videoUrl);
              const fallback = ytId ? ytThumbFallback(ytId) : null;
              return (
                <div key={v.id} className="flex gap-2 cursor-pointer group" onClick={() => navigateTo("watch", v.id)}>
                  <div className="relative w-40 aspect-video rounded-lg overflow-hidden flex-shrink-0 bg-neutral-200 dark:bg-neutral-800">
                    <SmartImage
                      src={v.thumbnailUrl}
                      fallbackSrc={fallback}
                      alt={v.title}
                      className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
                    />
                    <div className="absolute bottom-1 right-1 bg-black/80 text-white text-[10px] font-medium px-1 rounded">
                      {formatDuration(v.durationSeconds)}
                    </div>
                  </div>
                  <div className="flex flex-col py-0.5 pr-2">
                    <h4 className="text-sm font-medium line-clamp-2 leading-tight group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">
                      {v.title}
                    </h4>
                    <span className="text-xs text-neutral-600 dark:text-neutral-400 mt-1">{v.channelName}</span>
                    <span className="text-xs text-neutral-600 dark:text-neutral-400">{formatViews(v.views)} views â€¢ {formatTimeAgo(v.publishedAt)}</span>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    // ---------- Main App ----------
    function App() {
      const [user, setUser] = useState(null);
      const [videos, setVideos] = useState([]);
      const [channels, setChannels] = useState({});

      const [currentRoute, setCurrentRoute] = useState("home");
      const [activeVideoId, setActiveVideoId] = useState(null);

      const [searchQuery, setSearchQuery] = useState("");
      const [lastSearchTerm, setLastSearchTerm] = useState(""); // FIX: keep query for results page
      const [sortBy, setSortBy] = useState("newest");

      const [sidebarOpen, setSidebarOpen] = useState(true);
      const [isDarkMode, setIsDarkMode] = useState(true);
      const [watchProgress, setWatchProgress] = useState({});

      const [isUploadOpen, setIsUploadOpen] = useState(false);
      const [upUrl, setUpUrl] = useState("");
      const [upTitle, setUpTitle] = useState("");
      const [upDesc, setUpDesc] = useState("");

      // Animation classes
      const pageAnim = useEnterAnimation(currentRoute + ":" + activeVideoId, "fade-enter", "fade-enter-active");
      const modalAnim = useEnterAnimation(isUploadOpen ? "open" : "closed", "modal-enter", "modal-enter-active");
      const sidebarAnim = useEnterAnimation(sidebarOpen ? "open" : "closed", "sheet-enter", "sheet-enter-active");

      // Init from localStorage
      useEffect(() => {
        let uid = localStorage.getItem("ytClone_local_uid");
        if (!uid) {
          uid = "local_user_" + Math.random().toString(36).slice(2);
          localStorage.setItem("ytClone_local_uid", uid);
        }
        setUser({ uid });

        const savedVideos = localStorage.getItem("ytClone_videos");
        if (savedVideos) setVideos(JSON.parse(savedVideos));
        else {
          setVideos(initialVideos);
          localStorage.setItem("ytClone_videos", JSON.stringify(initialVideos));
        }

        const savedChannels = localStorage.getItem("ytClone_channels");
        if (savedChannels) setChannels(JSON.parse(savedChannels));

        const savedProgress = localStorage.getItem("ytClone_progress");
        if (savedProgress) setWatchProgress(JSON.parse(savedProgress));

        const savedTheme = localStorage.getItem("ytClone_theme");
        if (savedTheme === "light") setIsDarkMode(false);
      }, []);

      // Theme
      useEffect(() => {
        if (isDarkMode) {
          document.documentElement.classList.add("dark");
          localStorage.setItem("ytClone_theme", "dark");
        } else {
          document.documentElement.classList.remove("dark");
          localStorage.setItem("ytClone_theme", "light");
        }
      }, [isDarkMode]);

      // Deep link support (?v=...)
      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const v = params.get("v");
        if (v) {
          setCurrentRoute("watch");
          setActiveVideoId(v);
        }
      }, []);

      const saveProgress = (id, time) => {
        const newProgress = { ...watchProgress, [id]: time };
        setWatchProgress(newProgress);
        localStorage.setItem("ytClone_progress", JSON.stringify(newProgress));
      };

      const navigateTo = (route, videoId) => {
        setCurrentRoute(route);
        if (videoId) {
          setActiveVideoId(videoId);
          // update query param for share/deeplink
          const u = new URL(window.location.href);
          u.searchParams.set("v", videoId);
          window.history.replaceState({}, "", u.toString());
          window.scrollTo(0, 0);
        } else {
          // clear ?v when leaving watch
          const u = new URL(window.location.href);
          u.searchParams.delete("v");
          window.history.replaceState({}, "", u.toString());
        }
      };

      const handleUpdateVideo = (videoId, updates) => {
        setVideos((prev) => {
          const next = prev.map((v) => (v.id === videoId ? { ...v, ...updates } : v));
          localStorage.setItem("ytClone_videos", JSON.stringify(next));
          return next;
        });
      };

      const handleUpdateChannel = (channelId, updates) => {
        setChannels((prev) => {
          const next = { ...prev, [channelId]: { ...(prev[channelId] || {}), ...updates } };
          localStorage.setItem("ytClone_channels", JSON.stringify(next));
          return next;
        });
      };

      const processExternalLink = async (url) => {
        const ytId = getYouTubeId(url);
        const driveId = getDriveId(url);
        if (!ytId && !driveId) return null;

        const newId = ytId ? `yt_${ytId}` : `dr_${driveId}`;
        const platform = ytId ? "YouTube" : "Google Drive";

        let thumb = "https://via.placeholder.com/640x360.png?text=Shared+Video";
        if (ytId) thumb = ytThumb(ytId); // will fall back automatically in UI
        else if (driveId) thumb = "https://via.placeholder.com/640x360.png?text=Google+Drive+Video";

        const newVideoData = {
          id: newId,
          title: `Shared ${platform} Video`,
          description: `Added from URL.`,
          channelName: "Local User",
          publishedAt: new Date().toISOString(),
          createdAt: Date.now(),
          views: 0,
          durationSeconds: 0,
          tags: ["shared", platform.toLowerCase().replace(" ", "")],
          thumbnailUrl: thumb,
          videoUrl: url,
          likes: [],
          uploaderId: user ? user.uid : "anonymous",
        };

        const existing = videos.find((v) => v.id === newId);
        if (!existing) {
          const nextVideos = [newVideoData, ...videos];
          setVideos(nextVideos);
          localStorage.setItem("ytClone_videos", JSON.stringify(nextVideos));
        }
        return newId;
      };

      const handleSearch = async (e) => {
        e.preventDefault();
        const term = searchQuery.trim();
        if (!term) return;

        setLastSearchTerm(term); // FIX: persist for results page

        const newId = await processExternalLink(term);
        if (newId) {
          navigateTo("watch", newId);
          setSearchQuery("");
          return;
        }
        navigateTo("search");
      };

      const handleUploadSubmit = async (e) => {
        e.preventDefault();
        if (!upUrl.trim()) return;

        const ytId = getYouTubeId(upUrl);
        const driveId = getDriveId(upUrl);
        const vidId = generateId();

        let thumb = "https://via.placeholder.com/640x360.png?text=Shared+Video";
        if (ytId) thumb = ytThumb(ytId);
        else if (driveId) thumb = "https://via.placeholder.com/640x360.png?text=Google+Drive+Video";

        const newVideo = {
          id: vidId,
          title: upTitle || "Untitled Video",
          description: upDesc || "",
          channelName: "Local User",
          publishedAt: new Date().toISOString(),
          createdAt: Date.now(),
          views: 0,
          durationSeconds: 0,
          tags: ["community"],
          thumbnailUrl: thumb,
          videoUrl: upUrl,
          likes: [],
          uploaderId: user ? user.uid : "anonymous",
        };

        const nextVideos = [newVideo, ...videos];
        setVideos(nextVideos);
        localStorage.setItem("ytClone_videos", JSON.stringify(nextVideos));

        setIsUploadOpen(false);
        setUpUrl(""); setUpTitle(""); setUpDesc("");
        navigateTo("watch", vidId);
      };

      const handleDeleteVideo = (videoId) => {
        const nextVideos = videos.filter((v) => v.id !== videoId);
        setVideos(nextVideos);
        localStorage.setItem("ytClone_videos", JSON.stringify(nextVideos));
        navigateTo("home");
      };

      const activeVideo = videos.find((v) => v.id === activeVideoId);

      const searchResults = useMemo(() => {
        const term = (lastSearchTerm || "").toLowerCase();
        if (!term) return [];
        return videos.filter((v) => {
          return (
            (v.title || "").toLowerCase().includes(term) ||
            (v.description || "").toLowerCase().includes(term) ||
            (v.channelName || "").toLowerCase().includes(term) ||
            (v.tags || []).some((t) => (t || "").toLowerCase().includes(term))
          );
        });
      }, [videos, lastSearchTerm]);

      const sortedHomeVideos = useMemo(() => {
        return [...videos].sort((a, b) => {
          if (sortBy === "views") return (b.views || 0) - (a.views || 0);
          if (sortBy === "likes") return (b.likes?.length || 0) - (a.likes?.length || 0);
          return (b.createdAt || 0) - (a.createdAt || 0);
        });
      }, [videos, sortBy]);

      return (
        <div className="min-h-screen bg-neutral-50 dark:bg-neutral-900 text-neutral-900 dark:text-neutral-100 font-sans flex flex-col transition-colors">
          {/* HEADER */}
          <header className="sticky top-0 z-40 flex items-center justify-between px-4 h-16 bg-white dark:bg-neutral-900 border-b border-neutral-200 dark:border-neutral-800">
            <div className="flex items-center gap-4">
              <button
                onClick={() => setSidebarOpen((s) => !s)}
                className="p-2 hover:bg-neutral-100 dark:hover:bg-neutral-800 rounded-full transition-colors active:scale-[0.98]"
              >
                <Menu />
              </button>

              <div className="flex items-center gap-1 cursor-pointer select-none" onClick={() => navigateTo("home")}>
                <div className="bg-red-600 text-white p-1 rounded-lg">
                  <Play className="w-5 h-5" fill="currentColor" />
                </div>
                <span className="text-xl font-bold tracking-tighter">GitTube</span>
                <span className="ml-2 text-[10px] font-bold uppercase tracking-widest bg-neutral-200 dark:bg-neutral-800 px-2 py-0.5 rounded text-neutral-500">
                  Offline
                </span>
              </div>
            </div>

            <form onSubmit={handleSearch} className="flex-1 max-w-2xl px-4 flex">
              <div className="flex w-full items-center border border-neutral-300 dark:border-neutral-700 rounded-full overflow-hidden bg-neutral-50 dark:bg-neutral-800 focus-within:border-blue-500 transition-colors">
                <input
                  type="text"
                  placeholder="Search or paste YouTube/Drive URL..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="w-full px-4 py-2 bg-transparent outline-none placeholder-neutral-500 dark:placeholder-neutral-400"
                />
                <button
                  type="submit"
                  className="px-5 py-2 bg-neutral-100 dark:bg-neutral-700 hover:bg-neutral-200 dark:hover:bg-neutral-600 border-l border-neutral-300 dark:border-neutral-700 transition-colors active:scale-[0.98]"
                >
                  <Search />
                </button>
              </div>
            </form>

            <div className="flex items-center gap-2 sm:gap-4">
              <button
                onClick={() => setIsUploadOpen(true)}
                className="flex items-center gap-2 p-2 hover:bg-neutral-100 dark:bg-neutral-800 rounded-full sm:rounded-lg transition-colors border border-transparent sm:border-neutral-200 dark:sm:border-neutral-700 active:scale-[0.98]"
                title="Add Video"
              >
                <Plus className="w-5 h-5" />
                <span className="hidden sm:inline font-medium pr-1 text-sm">Add Local</span>
              </button>

              <button
                onClick={() => setIsDarkMode((d) => !d)}
                className="p-2 hover:bg-neutral-100 dark:hover:bg-neutral-800 rounded-full transition-colors active:scale-[0.98]"
                title="Toggle Dark Mode"
              >
                {isDarkMode ? <Sun /> : <Moon />}
              </button>

              <div className="w-8 h-8 rounded-full bg-blue-600 text-white flex items-center justify-center font-bold text-sm">
                L
              </div>
            </div>
          </header>

          {/* MAIN */}
          <div className="flex flex-1 overflow-hidden relative">
            {sidebarOpen && (
              <aside className={"w-64 flex-shrink-0 bg-white dark:bg-neutral-900 border-r border-neutral-200 dark:border-neutral-800 hidden md:block overflow-y-auto " + sidebarAnim}>
                <nav className="p-3 space-y-1">
                  <SidebarItem icon={<Home />} label="Home" active={currentRoute === "home"} onClick={() => navigateTo("home")} />
                  <SidebarItem icon={<Compass />} label="Explore" onClick={() => navigateTo("home")} />
                  <hr className="my-3 border-neutral-200 dark:border-neutral-800" />
                  <SidebarItem icon={<History />} label="History" onClick={() => navigateTo("home")} />
                </nav>

                <div className="p-4 mt-4 bg-neutral-100 dark:bg-neutral-800/50 rounded-lg mx-3">
                  <p className="text-xs font-semibold text-green-600 dark:text-green-400 mb-1">Offline Mode ðŸ”‹</p>
                  <p className="text-xs text-neutral-600 dark:text-neutral-400 leading-snug">
                    No cloud required. Videos, likes, and channels are saved locally directly in your browser.
                  </p>
                </div>
              </aside>
            )}

            <main className="flex-1 overflow-y-auto bg-neutral-100 dark:bg-neutral-950 p-4 sm:p-6 lg:p-8">
              <div className={pageAnim}>
                {currentRoute === "home" && (
                  <div className="max-w-7xl mx-auto">
                    <div className="flex gap-3 mb-6 overflow-x-auto pb-2">
                      <FilterChip label="Newest" active={sortBy === "newest"} onClick={() => setSortBy("newest")} />
                      <FilterChip label="Most Popular" active={sortBy === "likes"} onClick={() => setSortBy("likes")} />
                    </div>

                    {videos.length === 0 ? (
                      <div className="text-center py-20 text-neutral-500">Loading Local Data...</div>
                    ) : (
                      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                        {sortedHomeVideos.map((video) => (
                          <VideoCard
                            key={video.id}
                            video={video}
                            onClick={() => navigateTo("watch", video.id)}
                            progress={watchProgress[video.id]}
                          />
                        ))}
                      </div>
                    )}
                  </div>
                )}

                {currentRoute === "search" && (
                  <div className="max-w-4xl mx-auto">
                    <h2 className="text-xl font-bold mb-6">Search results for "{lastSearchTerm}"</h2>
                    <div className="flex flex-col gap-4">
                      {searchResults.length > 0 ? (
                        searchResults.map((video) => (
                          <HorizontalVideoCard key={video.id} video={video} onClick={() => navigateTo("watch", video.id)} />
                        ))
                      ) : (
                        <p className="text-neutral-500">No videos found. Try different keywords or paste a link to add it.</p>
                      )}
                    </div>
                  </div>
                )}

                {currentRoute === "watch" && activeVideo && (
                  <WatchView
                    video={activeVideo}
                    videos={videos}
                    navigateTo={navigateTo}
                    user={user}
                    channels={channels}
                    initialProgress={watchProgress[activeVideo.id] || 0}
                    onProgress={(time) => saveProgress(activeVideo.id, time)}
                    onDeleteVideo={handleDeleteVideo}
                    onUpdateVideo={handleUpdateVideo}
                    onUpdateChannel={handleUpdateChannel}
                  />
                )}
              </div>
            </main>

            {/* UPLOAD MODAL */}
            {isUploadOpen && (
              <div className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                <div className={"bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 rounded-2xl w-full max-w-lg shadow-2xl flex flex-col " + modalAnim}>
                  <div className="flex items-center justify-between p-4 border-b border-neutral-200 dark:border-neutral-800">
                    <h2 className="text-xl font-bold">Add Local Video</h2>
                    <button
                      onClick={() => setIsUploadOpen(false)}
                      className="p-2 hover:bg-neutral-100 dark:hover:bg-neutral-800 rounded-full transition-colors active:scale-[0.98]"
                    >
                      <X />
                    </button>
                  </div>

                  <form onSubmit={handleUploadSubmit} className="p-6 flex flex-col gap-4">
                    <div>
                      <label className="block text-sm font-medium mb-1">Video URL (YouTube, G-Drive, or .mp4)</label>
                      <input
                        required
                        type="url"
                        value={upUrl}
                        onChange={(e) => setUpUrl(e.target.value)}
                        placeholder="https://www.youtube.com/watch?v=... or Drive link"
                        className="w-full px-4 py-2 border border-neutral-300 dark:border-neutral-700 rounded-lg bg-neutral-50 dark:bg-neutral-800 focus:border-blue-500 outline-none transition-colors"
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium mb-1">Title</label>
                      <input
                        required
                        type="text"
                        value={upTitle}
                        onChange={(e) => setUpTitle(e.target.value)}
                        placeholder="My Awesome Video"
                        className="w-full px-4 py-2 border border-neutral-300 dark:border-neutral-700 rounded-lg bg-neutral-50 dark:bg-neutral-800 focus:border-blue-500 outline-none transition-colors"
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium mb-1">Description</label>
                      <textarea
                        value={upDesc}
                        onChange={(e) => setUpDesc(e.target.value)}
                        placeholder="Tell viewers about your video..."
                        rows="3"
                        className="w-full px-4 py-2 border border-neutral-300 dark:border-neutral-700 rounded-lg bg-neutral-50 dark:bg-neutral-800 focus:border-blue-500 outline-none resize-none transition-colors"
                      ></textarea>
                    </div>

                    <div className="mt-4 flex justify-end gap-3">
                      <button
                        type="button"
                        onClick={() => setIsUploadOpen(false)}
                        className="px-5 py-2 font-medium hover:bg-neutral-100 dark:hover:bg-neutral-800 rounded-lg transition-colors active:scale-[0.98]"
                      >
                        Cancel
                      </button>
                      <button
                        type="submit"
                        className="px-5 py-2 bg-blue-600 text-white font-medium rounded-lg hover:bg-blue-700 transition-colors active:scale-[0.98]"
                      >
                        Save Local Video
                      </button>
                    </div>
                  </form>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>